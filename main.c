/****************************调试问题*************************************
1，当用DCO设置的频率太高的话，会使程序跑飞
2, TimerB 有定时器中断和溢出中断，注意理解
3,TimerB在转载时有问题，主要采用实时赋值的方法时，可正常运行
************************************************************************/
/******************************更新**************************************
3.21-1  1.将TBCCRx的赋值改为实时赋值
        2.更改了算法，将浮点转换为定点运算，使运算更为快速
3.21-2  1.解决了占空比只能在50%~100%之间变化的问题
************************************************************************/

#include  "msp430x44x.h "
#define  Cp 360
/*----------系统频率--载波频率 调制波频率--最大脉宽--最小脉宽--*/
unsigned int sysHz=10, triHz=9, sinHz=50,  HzMax=540,   HzMin=15, HzM=555,N2,k=0;
/*--调制系数--MHz------KHz--------Hz-----------------微秒---*/
/*----------载波比----PI/N--PI/4--PI*3/4-Tc/4-Tc*m/4-sine[j]/q14--*/
unsigned int N_ts=180,PI_N,PI_25,PI_75,Tc_2,Tc_2m,Sine_Q14;
float  m=0.9;
//unsigned int s[1204];
int sine[361]={0,286,572,857,1143,1428,           //SIN值表,Q14格式有符号数             
             1713,1997,2280,2563,2845,
             3126,3406,3686,3964,4240,
             4516, 4790,5063,5334,5604,
             5872,6138,6402,6664, 6924,
             7182,7438,7692,7943,8192,
             8438,8682,8923,9162,9397,
             9630,9860,10087,10311,10531,
             10749,10963,11174,11381,11585,
             11786,11982,12176,12365,12551,
             12733,12911,13085,13255,13421,
             13583,13741,13894,14044,14189,
             14330,14466,14598,14726,14849,
             14968,15082,15191,15296,15396,
             15491,15582,15668,15749,15826,
             15897,15964,16026,16083,16135,
             16182,16225,16262,16294,16322,
             16344,16362,16374, 16382,16384,            //;90
             16382,16374,16362,16344,16322,
             16294,16262,16225,16182,16135,
             16083,16026,15964,15897,15826,
             15749,15668,15582,15491,15396,
             15296,15191,15082,14968,14849,
             14726,14598,14466,14330,14189,
             14044,13894,13741,13583,13421,
             13255,13085,12911,12733,12551,
             12365,12176,11982,11786,11585,
             11381,11174,10963,10749,10531,
             10311,10087,9860,9630,9397,
             9162,8923,8682,8438,8192,
             7943,7692,7438,7182,6924,
             6664,6402,6138,5872,5604,
             5334,5063,4790,4516,4240,  
             3964,3686,3406,3126,2845,
             2563,2280,1997,1713,1428,
             1143,857,572,286, 0,                      //;180               
             286,572,857,1143,1428,
             1713,1997,2280,2563,2845,
             3126,3406,3686,3964,4240,
             4516, 4790,5063,5334,5604,
             5872,6138,6402,6664, 6924,
             7182,7438,7692,7943,8192,
             8438,8682,8923,9162,9397,
             9630,9860,10087,10311,10531,
             10749,10963,11174,11381,11585,
             11786,11982,12176,12365,12551,
             12733,12911,13085,13255,13421,
             13583,13741,13894,14044,14189,
             14330,14466,14598,14726,14849,
             14968,15082,15191,15296,15396,
             15491,15582,15668,15749,15826,
             15897,15964,16026,16083,16135,
             16182,16225,16262,16294,16322,
             16344,16362,16374, 16382,16384,            //;90

             16382,16374,16362,16344,16322,
             16294,16262,16225,16182,16135,
             16083,16026,15964,15897,15826,
             15749,15668,15582,15491,15396,
             15296,15191,15082,14968,14849,
             14726,14598,14466,14330,14189,
             14044,13894,13741,13583,13421,
             13255,13085,12911,12733,12551,
             12365,12176,11982,11786,11585,
             11381,11174,10963,10749,10531,
             10311,10087,9860,9630,9397,
             9162,8923,8682,8438,8192,
             7943,7692,7438,7182,6924,
             6664,6402,6138,5872,5604,
             5334,5063,4790,4516,4240,  
             3964,3686,3406,3126,2845,
             2563,2280,1997,1713,1428,
             1143,857,572,286, 0};

void DCO_SMCLK();
void CalInit();
void TimerBInit();
void main(void)
{  
  WDTCTL = WDTPW + WDTHOLD;             // Stop WDT
  DCO_SMCLK();
  CalInit();                            //计算值初始化
  TimerBInit();                          //TimerB初始化
  
  _EINT();                              // Enable interrupts

  for (;;)
  {
    _BIS_SR(CPUOFF);                    // CPU off
    _NOP();                             // Required only for C-spy
  }
}
//---------------------------设置SMCLK的频率--------------------
void DCO_SMCLK(void)               //设置SMCLK的频率为10MHZ
{ 
  unsigned int i;
  FLL_CTL0 = OSCCAP_3+DCOPLUS;    // set load capacitance for 32k xtal
  FLL_CTL1 = FLL_CTL1 & ~XT2OFF;  // clear bit = high freq xtal on
  SCFI0|=FLLD_8+FN_8;
  SCFQCTL=38;
  do                              // loop until flag is clear
  {
    FLL_CTL0 = FLL_CTL0 & ~XT2OF; // clear high freq oscillator fault flag
    for (i = 50000; i; i--);      // delay for crystal to start and FLL to lock
  }
  while (FLL_CTL0 & XT2OF);       // test high freq oscillator fault flag
}
//----------------------------计算值初始化-----------------------------
void CalInit()
{
  PI_N=1;                        //PI_N为PI与载波比的比值180/180
  PI_25=120;                     //PI*2/3
  Tc_2=275;                      //TC/(2*2)=110us/4,其计数周期为27.5us/0.1us=275
  Tc_2m=247;                     //Tc*m/4=Tc_4*m=247
  N2=N_ts*2;                      
}
//-----------------------------TimerB初始化------------------------------
void TimerBInit(void)
{  
  TBCTL |= TBSSEL_2+TBCLR+TBIE;//+TBCLGRP_1;       // smCLK, Clear TAR,分为三组挂载
  TBCCR0=555;                             //定时器计数周期,载波周期与两倍的系统周期的比
  TBCCTL1 = OUTMOD_2;//+CLLD_1 ;             // 在CCRx到0加载新比较器数据，PWM翻转/复位
  TBCCTL3 = OUTMOD_2;//+CLLD_1 ;             // 在CCRx到0加载新比较器数据，PWM翻转/复位
  TBCCTL5 = OUTMOD_2;//+CLLD_1 ;             // 在CCRx到0加载新比较器数据，PWM翻转/复位
  P2DIR|= BIT2+BIT3; 
  P2SEL |= BIT2+BIT3;                     // P2.2~P2.3 TB1~2 otion
  P3DIR |= BIT4+BIT5+BIT6+BIT7;           // P3.4~P3.7 output
  P3SEL |= BIT4+BIT5+BIT6+BIT7;           // P3.4~P3.7 TB3~6 otion  
  TBCTL |= MC_3;                          // Start Timer_B in up/down mode
} 
// -------------TimerA interrupt service routine-----------
#pragma vector=TIMERB1_VECTOR
__interrupt void Timer_B(void)
{
   TBCTL&=~TBIFG;
   unsigned int j;          
   int T_1,T_3,T_5;
   unsigned long Tc2mSQ;   
   //-------------------------T_1--------------------------
   j=k*PI_N;
   if((j<360)&&(j>=180))
   {
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_1=Tc_2-Tc2mSQ;
   }
   else 
   {
     if(j>=Cp)
       j=j-Cp;
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_1=Tc_2+Tc2mSQ;
   }
   //-------------------------T_2--------------------------
   j=j+120;
   if((j<360)&&(j>=180))
   {
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_3=Tc_2-Tc2mSQ;
   }
   else 
   {
     if(j>=Cp)
       j=j-Cp;
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_3=Tc_2+Tc2mSQ;
   }
   //-------------------------T_3--------------------------
   j=j+120;
   if((j<360)&&(j>=180))
   {
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_5=Tc_2-Tc2mSQ;
   }
   else 
   {
     if(j>=Cp)
       j=j-Cp;
     Tc2mSQ=((long)Tc_2m*sine[j]);
     Tc2mSQ=Tc2mSQ>>14;
     T_5=Tc_2+Tc2mSQ;
   }      
   if(T_1<HzMin)
     T_1=0;
   if(T_1>HzMax)
     T_1=HzM;    
   if(T_3<HzMin)
     T_3=0;
   if(T_3>HzMax)
     T_3=HzM;
   if(T_5<HzMin)
     T_5=0;
   if(T_5>HzMax)
     T_5=HzM;
   TBCCR1=T_1;       //s[i];
   TBCCR3=T_3;       //s[i+n];
   TBCCR5=T_5;       //s[i+N2]; 
   k++; 
   if(k>N2)
     k=0;
}
